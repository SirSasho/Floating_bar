Ще разгледаме един вариант за кодиране на рационални числа в 32 бита, а именно :
-най - старшият бит показва знака, аналогично на стандартните типове
- следващите 5 бита са число, наречено bar position, или B
- знаменателят е записан в най - младшите B бита
- числителят е записан в останалите 26 - B на брой бита
Уточнения :
-числителят е винаги неотрицателен, а знаменателя строго положителен;
-числителят и знаменателят винаги са взаимнопрости числа.Например 4 / 6 не се счита за валидна дроб, ами се опростява до 2 / 3 и това се кодира;
-целите числа считаме за рационални със знаменател 1;
-не разглеждаме числа, чиито опростени числител и знаменател не се побират в общо 26 бита.
Функции:
// Опростява и кодира дробта n/d в 32-битово цяло число
unsigned makeRat(int n, int d);

// Връща числителя на дадено рационално число, със знака на числото (т.е. отрицателно число за отрицателни дроби)
int getNumer(unsigned rat);

// Връща знаменателя на дадено рационално число, винаги положителен
int getDenom(unsigned rat);

// Изчисляват _точно_ и кодират съответно сумата/разликата/произведението/частното на дадени две рационални числа.
// Това означава, че използване на float и double в междинните изчисления е забранено (!)
unsigned ratAdd(unsigned r1, unsigned r2);
unsigned ratSub(unsigned r1, unsigned r2);
unsigned ratMul(unsigned r1, unsigned r2);
unsigned ratDiv(unsigned r1, unsigned r2);

// Връща реципрочното на дадено рационално число
unsigned ratRec(unsigned rat);
// Връща противоположното на дадено рационално число
unsigned ratNeg(unsigned rat);
// Връща абсолютната стойност на дадено рационално число
unsigned ratAbs(unsigned rat);

// Превръща рационално число в стандартно дробно число
float rat2float(unsigned rat);
